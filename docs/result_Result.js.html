<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>result/Result.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Either.html">Either</a><ul class='methods'><li data-type='method'><a href="Either.html#.andThen">andThen</a></li><li data-type='method'><a href="Either.html#.ap">ap</a></li><li data-type='method'><a href="Either.html#.chain">chain</a></li><li data-type='method'><a href="Either.html#.isLeft">isLeft</a></li><li data-type='method'><a href="Either.html#.isRight">isRight</a></li><li data-type='method'><a href="Either.html#.Left.of">Left.of</a></li><li data-type='method'><a href="Either.html#.lift">lift</a></li><li data-type='method'><a href="Either.html#.map">map</a></li><li data-type='method'><a href="Either.html#.of">of</a></li><li data-type='method'><a href="Either.html#.Right.of">Right.of</a></li><li data-type='method'><a href="Either.html#.try">try</a></li><li data-type='method'><a href="Either.html#andThen">andThen</a></li><li data-type='method'><a href="Either.html#ap">ap</a></li><li data-type='method'><a href="Either.html#caseOf">caseOf</a></li><li data-type='method'><a href="Either.html#cata">cata</a></li><li data-type='method'><a href="Either.html#chain">chain</a></li><li data-type='method'><a href="Either.html#isLeft">isLeft</a></li><li data-type='method'><a href="Either.html#isRight">isRight</a></li><li data-type='method'><a href="Either.html#map">map</a></li></ul></li><li><a href="Either.Left.html">Left</a><ul class='methods'><li data-type='method'><a href="Either.Left.html#andThen">andThen</a></li><li data-type='method'><a href="Either.Left.html#ap">ap</a></li><li data-type='method'><a href="Either.Left.html#caseOf">caseOf</a></li><li data-type='method'><a href="Either.Left.html#cata">cata</a></li><li data-type='method'><a href="Either.Left.html#chain">chain</a></li><li data-type='method'><a href="Either.Left.html#isLeft">isLeft</a></li><li data-type='method'><a href="Either.Left.html#isRight">isRight</a></li><li data-type='method'><a href="Either.Left.html#map">map</a></li><li data-type='method'><a href="Either.Left.html#of">of</a></li></ul></li><li><a href="Either.Right.html">Right</a><ul class='methods'><li data-type='method'><a href="Either.Right.html#andThen">andThen</a></li><li data-type='method'><a href="Either.Right.html#ap">ap</a></li><li data-type='method'><a href="Either.Right.html#caseOf">caseOf</a></li><li data-type='method'><a href="Either.Right.html#cata">cata</a></li><li data-type='method'><a href="Either.Right.html#chain">chain</a></li><li data-type='method'><a href="Either.Right.html#isLeft">isLeft</a></li><li data-type='method'><a href="Either.Right.html#isRight">isRight</a></li><li data-type='method'><a href="Either.Right.html#map">map</a></li><li data-type='method'><a href="Either.Right.html#of">of</a></li></ul></li><li><a href="IO.html">IO</a><ul class='methods'><li data-type='method'><a href="IO.html#.ap">ap</a></li><li data-type='method'><a href="IO.html#.chain">chain</a></li><li data-type='method'><a href="IO.html#.map">map</a></li><li data-type='method'><a href="IO.html#.of">of</a></li><li data-type='method'><a href="IO.html#ap">ap</a></li><li data-type='method'><a href="IO.html#chain">chain</a></li><li data-type='method'><a href="IO.html#map">map</a></li></ul></li><li><a href="Maybe.html">Maybe</a><ul class='methods'><li data-type='method'><a href="Maybe.html#.andThen">andThen</a></li><li data-type='method'><a href="Maybe.html#.ap">ap</a></li><li data-type='method'><a href="Maybe.html#.chain">chain</a></li><li data-type='method'><a href="Maybe.html#.fromNullable">fromNullable</a></li><li data-type='method'><a href="Maybe.html#.isJust">isJust</a></li><li data-type='method'><a href="Maybe.html#.isNothing">isNothing</a></li><li data-type='method'><a href="Maybe.html#.map">map</a></li><li data-type='method'><a href="Maybe.html#.of">of</a></li><li data-type='method'><a href="Maybe.html#.withDefault">withDefault</a></li><li data-type='method'><a href="Maybe.html#andThen">andThen</a></li><li data-type='method'><a href="Maybe.html#ap">ap</a></li><li data-type='method'><a href="Maybe.html#caseOf">caseOf</a></li><li data-type='method'><a href="Maybe.html#cata">cata</a></li><li data-type='method'><a href="Maybe.html#chain">chain</a></li><li data-type='method'><a href="Maybe.html#isJust">isJust</a></li><li data-type='method'><a href="Maybe.html#isNothing">isNothing</a></li><li data-type='method'><a href="Maybe.html#map">map</a></li><li data-type='method'><a href="Maybe.html#withDefault">withDefault</a></li></ul></li><li><a href="Maybe.Just.html">Just</a><ul class='methods'><li data-type='method'><a href="Maybe.Just.html#andThen">andThen</a></li><li data-type='method'><a href="Maybe.Just.html#ap">ap</a></li><li data-type='method'><a href="Maybe.Just.html#caseOf">caseOf</a></li><li data-type='method'><a href="Maybe.Just.html#cata">cata</a></li><li data-type='method'><a href="Maybe.Just.html#chain">chain</a></li><li data-type='method'><a href="Maybe.Just.html#isJust">isJust</a></li><li data-type='method'><a href="Maybe.Just.html#isNothing">isNothing</a></li><li data-type='method'><a href="Maybe.Just.html#map">map</a></li><li data-type='method'><a href="Maybe.Just.html#withDefault">withDefault</a></li></ul></li><li><a href="Maybe.Nothing.html">Nothing</a><ul class='methods'><li data-type='method'><a href="Maybe.Nothing.html#andThen">andThen</a></li><li data-type='method'><a href="Maybe.Nothing.html#ap">ap</a></li><li data-type='method'><a href="Maybe.Nothing.html#caseOf">caseOf</a></li><li data-type='method'><a href="Maybe.Nothing.html#cata">cata</a></li><li data-type='method'><a href="Maybe.Nothing.html#chain">chain</a></li><li data-type='method'><a href="Maybe.Nothing.html#isJust">isJust</a></li><li data-type='method'><a href="Maybe.Nothing.html#isNothing">isNothing</a></li><li data-type='method'><a href="Maybe.Nothing.html#map">map</a></li><li data-type='method'><a href="Maybe.Nothing.html#withDefault">withDefault</a></li></ul></li><li><a href="module-Zoom.ADT.html">ADT</a><ul class='methods'><li data-type='method'><a href="module-Zoom.ADT.html#.tag">tag</a></li><li data-type='method'><a href="module-Zoom.ADT.html#.union">union</a></li></ul></li><li><a href="Reader.html">Reader</a><ul class='methods'><li data-type='method'><a href="Reader.html#.ap">ap</a></li><li data-type='method'><a href="Reader.html#.chain">chain</a></li><li data-type='method'><a href="Reader.html#.map">map</a></li><li data-type='method'><a href="Reader.html#.of">of</a></li><li data-type='method'><a href="Reader.html#ap">ap</a></li><li data-type='method'><a href="Reader.html#chain">chain</a></li><li data-type='method'><a href="Reader.html#map">map</a></li></ul></li><li><a href="ReaderT.html">ReaderT</a><ul class='methods'><li data-type='method'><a href="ReaderT.html#.lift">lift</a></li><li data-type='method'><a href="ReaderT.html#.of">of</a></li><li data-type='method'><a href="ReaderT.html#andThen">andThen</a></li><li data-type='method'><a href="ReaderT.html#ap">ap</a></li><li data-type='method'><a href="ReaderT.html#chain">chain</a></li><li data-type='method'><a href="ReaderT.html#map">map</a></li></ul></li><li><a href="Result.html">Result</a><ul class='methods'><li data-type='method'><a href="Result.html#.andThen">andThen</a></li><li data-type='method'><a href="Result.html#.ap">ap</a></li><li data-type='method'><a href="Result.html#.chain">chain</a></li><li data-type='method'><a href="Result.html#.Failure.of">Failure.of</a></li><li data-type='method'><a href="Result.html#.isFailure">isFailure</a></li><li data-type='method'><a href="Result.html#.isSuccess">isSuccess</a></li><li data-type='method'><a href="Result.html#.map">map</a></li><li data-type='method'><a href="Result.html#.of">of</a></li><li data-type='method'><a href="Result.html#.Success.of">Success.of</a></li><li data-type='method'><a href="Result.html#andThen">andThen</a></li><li data-type='method'><a href="Result.html#ap">ap</a></li><li data-type='method'><a href="Result.html#caseOf">caseOf</a></li><li data-type='method'><a href="Result.html#cata">cata</a></li><li data-type='method'><a href="Result.html#chain">chain</a></li><li data-type='method'><a href="Result.html#isFailure">isFailure</a></li><li data-type='method'><a href="Result.html#isSuccess">isSuccess</a></li><li data-type='method'><a href="Result.html#map">map</a></li></ul></li><li><a href="Result.Failure.html">Failure</a><ul class='methods'><li data-type='method'><a href="Result.Failure.html#andThen">andThen</a></li><li data-type='method'><a href="Result.Failure.html#ap">ap</a></li><li data-type='method'><a href="Result.Failure.html#caseOf">caseOf</a></li><li data-type='method'><a href="Result.Failure.html#cata">cata</a></li><li data-type='method'><a href="Result.Failure.html#chain">chain</a></li><li data-type='method'><a href="Result.Failure.html#isFailure">isFailure</a></li><li data-type='method'><a href="Result.Failure.html#isSuccess">isSuccess</a></li><li data-type='method'><a href="Result.Failure.html#map">map</a></li><li data-type='method'><a href="Result.Failure.html#of">of</a></li></ul></li><li><a href="Result.Success.html">Success</a><ul class='methods'><li data-type='method'><a href="Result.Success.html#andThen">andThen</a></li><li data-type='method'><a href="Result.Success.html#ap">ap</a></li><li data-type='method'><a href="Result.Success.html#caseOf">caseOf</a></li><li data-type='method'><a href="Result.Success.html#cata">cata</a></li><li data-type='method'><a href="Result.Success.html#chain">chain</a></li><li data-type='method'><a href="Result.Success.html#isFailure">isFailure</a></li><li data-type='method'><a href="Result.Success.html#isSuccess">isSuccess</a></li><li data-type='method'><a href="Result.Success.html#map">map</a></li><li data-type='method'><a href="Result.Success.html#of">of</a></li></ul></li><li><a href="Task.html">Task</a><ul class='methods'><li data-type='method'><a href="Task.html#.andThen">andThen</a></li><li data-type='method'><a href="Task.html#.ap">ap</a></li><li data-type='method'><a href="Task.html#.chain">chain</a></li><li data-type='method'><a href="Task.html#.fork">fork</a></li><li data-type='method'><a href="Task.html#.lift">lift</a></li><li data-type='method'><a href="Task.html#.liftNode">liftNode</a></li><li data-type='method'><a href="Task.html#.map">map</a></li><li data-type='method'><a href="Task.html#.of">of</a></li><li data-type='method'><a href="Task.html#.parallel">parallel</a></li><li data-type='method'><a href="Task.html#.recover">recover</a></li><li data-type='method'><a href="Task.html#.reject">reject</a></li><li data-type='method'><a href="Task.html#.toPromise">toPromise</a></li><li data-type='method'><a href="Task.html#andThen">andThen</a></li><li data-type='method'><a href="Task.html#ap">ap</a></li><li data-type='method'><a href="Task.html#chain">chain</a></li><li data-type='method'><a href="Task.html#map">map</a></li><li data-type='method'><a href="Task.html#recover">recover</a></li><li data-type='method'><a href="Task.html#toPromise">toPromise</a></li></ul></li><li><a href="Tuple.html">Tuple</a><ul class='methods'><li data-type='method'><a href="Tuple.html#.equals">equals</a></li><li data-type='method'><a href="Tuple.html#.fst">fst</a></li><li data-type='method'><a href="Tuple.html#.map">map</a></li><li data-type='method'><a href="Tuple.html#.mapLeft">mapLeft</a></li><li data-type='method'><a href="Tuple.html#.snd">snd</a></li><li data-type='method'><a href="Tuple.html#equals">equals</a></li><li data-type='method'><a href="Tuple.html#fst">fst</a></li><li data-type='method'><a href="Tuple.html#Iterator">Iterator</a></li><li data-type='method'><a href="Tuple.html#map">map</a></li><li data-type='method'><a href="Tuple.html#mapLeft">mapLeft</a></li><li data-type='method'><a href="Tuple.html#snd">snd</a></li><li data-type='method'><a href="Tuple.html#toString">toString</a></li></ul></li><li><a href="Validation.html">Validation</a><ul class='methods'><li data-type='method'><a href="Validation.html#.andThen">andThen</a></li><li data-type='method'><a href="Validation.html#.ap">ap</a></li><li data-type='method'><a href="Validation.html#.chain">chain</a></li><li data-type='method'><a href="Validation.html#.concat">concat</a></li><li data-type='method'><a href="Validation.html#.empty">empty</a></li><li data-type='method'><a href="Validation.html#.isFailure">isFailure</a></li><li data-type='method'><a href="Validation.html#.isSuccess">isSuccess</a></li><li data-type='method'><a href="Validation.html#.map">map</a></li><li data-type='method'><a href="Validation.html#.of">of</a></li><li data-type='method'><a href="Validation.html#andThen">andThen</a></li><li data-type='method'><a href="Validation.html#ap">ap</a></li><li data-type='method'><a href="Validation.html#caseOf">caseOf</a></li><li data-type='method'><a href="Validation.html#cata">cata</a></li><li data-type='method'><a href="Validation.html#chain">chain</a></li><li data-type='method'><a href="Validation.html#concat">concat</a></li><li data-type='method'><a href="Validation.html#isFailure">isFailure</a></li><li data-type='method'><a href="Validation.html#isSuccess">isSuccess</a></li><li data-type='method'><a href="Validation.html#map">map</a></li></ul></li><li><a href="Validation.Failure.html">Failure</a><ul class='methods'><li data-type='method'><a href="Validation.Failure.html#.of">of</a></li><li data-type='method'><a href="Validation.Failure.html#andThen">andThen</a></li><li data-type='method'><a href="Validation.Failure.html#ap">ap</a></li><li data-type='method'><a href="Validation.Failure.html#caseOf">caseOf</a></li><li data-type='method'><a href="Validation.Failure.html#cata">cata</a></li><li data-type='method'><a href="Validation.Failure.html#chain">chain</a></li><li data-type='method'><a href="Validation.Failure.html#concat">concat</a></li><li data-type='method'><a href="Validation.Failure.html#isFailure">isFailure</a></li><li data-type='method'><a href="Validation.Failure.html#isSuccess">isSuccess</a></li><li data-type='method'><a href="Validation.Failure.html#map">map</a></li></ul></li><li><a href="Validation.Success.html">Success</a><ul class='methods'><li data-type='method'><a href="Validation.Success.html#.of">of</a></li><li data-type='method'><a href="Validation.Success.html#andThen">andThen</a></li><li data-type='method'><a href="Validation.Success.html#ap">ap</a></li><li data-type='method'><a href="Validation.Success.html#caseOf">caseOf</a></li><li data-type='method'><a href="Validation.Success.html#cata">cata</a></li><li data-type='method'><a href="Validation.Success.html#chain">chain</a></li><li data-type='method'><a href="Validation.Success.html#concat">concat</a></li><li data-type='method'><a href="Validation.Success.html#isFailure">isFailure</a></li><li data-type='method'><a href="Validation.Success.html#isSuccess">isSuccess</a></li><li data-type='method'><a href="Validation.Success.html#map">map</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">result/Result.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import __ from 'ramda/src/__';
import curry from 'ramda/src/curry';
import always from 'ramda/src/always';
import compose from 'ramda/src/compose';
import { union } from '../adt';

/**
 * @class Result
 * @abstract
 * @description
 * `Result` is an abstraction around error handling that allows the user
 * to return their errors instead of throw them. `Result` is a super class
 * with two constructors, `Failure` and `Success`. The `Success` constructor
 * represents a successful operation, and the `Failure` constructor represents
 * an unsuccessful operation with an embedded error message. You can chain
 * functions that return `Result` instances by using `.chain` or `.andThen`.
 *
 * ---
 *  #### Fantasy Land Implementations
 *  `Applicative`, `Functor`, `Apply`, `Chain`, `Monad`
 * @example
 * import { Result } from 'zoomjs';
 *
 * // Expose the constructors
 * const { Failure, Success } = Result;
 *
 * const toInteger = (number) => {
 *   const integer = parseInt(number, 10);
 *
 *   if (isNaN(integer)) {
 *     return Failure('Not a number!');
 *   }
 *
 *   return Success(number);
 * };
 *
 * toInteger('32') // Success(32)
 * toInteger(null) // Failure(Not a number!)
 */
const Result = union('Result', {
  /**
   * @class Result.Success
   * @extends Result
   */
  Success: ['value'],

  /**
   * @class Result.Failure
   * @extends Result
   */
  Failure: ['value'],
});

const Success = Result.Success;
const Failure = Result.Failure;

/*
 |------------------------------------------------------------------------------
 | Static Members
 |------------------------------------------------------------------------------
 */

/**
 * @description Lift a value into a successful 'Success' context.
 * @memberof Result
 * @since 1.0.0-beta
 * @implements Applicative
 * @example
 * import { Result } from 'zoomjs';
 *
 * Result.of(1).toString();
 * // => 'Success(1)'
 *
 * @param  {B} value The value to put in the Result
 * @return {Result&lt;A, B>}
 */
Result.of = function of(value) {
  return Success(value);
};

/**
 * @description Lift a value into a successful 'Success' context.
 * @memberof Result
 * @since 1.0.0-beta
 * @implements Applicative
 * @example
 * import { Success } from 'zoomjs/result';
 *
 * Success.of(1).toString();
 * // => 'Success(1)'
 *
 * @param  {B} value The value to put in the Result
 * @return {Result&lt;A, B>}
 */
Success.of = function of(value) {
  return Success(value);
};

/**
 * @description Lift a value into an unsuccessful 'Failure' context.
 * @memberof Result
 * @since 1.0.0-beta
 * @implements Applicative
 * @example
 * import { Failure } from 'zoomjs/result';
 *
 * Failure.of(1).toString();
 * // => 'Failure(1)'
 *
 * @param  {A} value The value to put in the Result
 * @return {Result&lt;A, B>}
 */
Failure.of = function of(value) {
  return Failure(value);
};

/**
 * @description Apply a transformation to the Result if it is an instance
 * of "Success". Otherwise, ignore the transformation and return the instance.
 * This is how you can switch from a 'Success' to 'Failure' instance and stop
 * subsequent transformations from being applied. An alias for {@link Result.andThen}
 * @memberof Result
 * @static
 * @function
 * @since 1.0.0-beta
 * @implements Chain
 * @see {@link Result.andThen}
 * @example
 * // chain Result a b :: (b -> Result a c) -> Result a c
 * import { chain, Failure, Success } from 'zoomjs/result';
 *
 * // toUpper :: String -> Result String String
 * const toUpper = x =>
 *   typeof x !== 'string'
 *     ? Failure.of('toUpper() recieved a non string.')
 *     : Success.of(x.toUpperCase());
 *
 * // A "Success" will apply the next operation
 * chain(toUpper, Success.of('boom'));
 * // => Success(BOOM)
 *
 * // A "Failure" will ignore the next operation
 * chain(toUpper, Failure.of('yea right'));
 * // => Failure(yea right)
 *
 * @param  {function} transform The transformation to apply to the inner value
 * @param  {Result&lt;A, B>} result The result instance.
 * @return {Result&lt;A, C>}
 */
Result.chain = curry((transform, result) =>
  result.cata({
    Failure: always(result),
    Success: transform,
  }));

/**
 * @description Apply a transformation to the Result if it is an instance
 * of "Success". Otherwise, ignore the transformation and return the instance.
 * This is how you can switch from a 'Success' to 'Failure' instance and stop
 * subsequent transformations from being applied. An alias for {@link Result.chain}
 * @memberof Result
 * @since 1.0.0-beta
 * @function andThen
 * @static
 * @see {@link Result.chain}
 * @example
 * // andThen Result a b :: (b -> Result a c) -> Result a c
 * import { andThen, Failure, Success } from 'zoomjs/result';
 *
 * // toUpper :: String -> Result String String
 * const toUpper = x =>
 *   typeof x !== 'string'
 *     ? Failure.of('toUpper() recieved a non string.')
 *     : Success.of(x.toUpperCase());
 *
 * // A "Success" will apply the next operation
 * andThen(toUpper, Success.of('boom'));
 * // => Success(BOOM)
 *
 * // A "Failure" will ignore the next operation
 * andThen(toUpper, Failure.of('yea right'));
 * // => Failure(yea right)
 *
 * @param  {function} transform The transformation to apply to the inner value
 * @param  {Result&lt;A, B>} result The result instance.
 * @return {Result&lt;A, C>}
 */
Result.andThen = Result.chain;

/**
 * @description `map` is very similar to {@link Result.andThen} and
 * {@link Result.chain} in that it only runs the function if the
 * result is an instance of `Just`. The main difference is that {@link Result.andThen}
 * and {@link Result.chain} expect the functions you give them to return
 * new `Result` instances, and map let's you use plain old functions.
 * @memberof Result
 * @since 1.0.0-beta
 * @implements Functor
 * @function map
 * @static
 * @example
 * // map Result a b :: (b -> c) -> Result a c
 * import { map, Failure, Success } from 'zoomjs/result';
 *
 * // toUpper :: String -> String
 * const toUpper = x => x.toUpperCase();
 *
 * // A "Success" will run the next operation
 * map(toUpper, Success.of('yay'));
 * // => Success('YAY!');
 *
 * // A "Failure" will ignore the next operation
 * map(toUpper, Failure.of('nay!'));
 * // => Failure('nay!');
 *
 * @param  {function} transform The transformation to apply to the inner value
 * @param  {Result&lt;A, B>} result The result instance.
 * @return {Result&lt;A, C>}
 */
Result.map = curry((transform, result) =>
  Result.chain(compose(Result.of, transform), result));

/**
 * @description
 * `ap` is just like `map`, allowing a user to use plain old functions to
 * transform values hidden away in `Result`s. The only difference is that
 * instead of giving it the function, you give it an `Result` of the function.
 * This is known as the `Apply` type in fantasy land JS.
 *
 * @memberof Result
 * @since 1.0.0-beta
 * @implements Apply
 * @function ap
 * @static
 * @example
 * // ap :: Apply (b -> c) -> Result a b -> Result a c
 * import { ap, Failure, Success } from 'zoomjs/result';
 *
 * // toUpperE :: Result a (String -> String)
 * const toUpperE = Success(x => x.toUpperCase());
 *
 * // A "Success" will apply the next operation
 * ap(toUpperE, Success.of('boom'));
 * // => Success(BOOM)
 *
 * // A "Failure" will ignore the next operation
 * ap(toUpperE, Failure.of('yea right'));
 * // => Failure(yea right)
 *
 * @param  {Result&lt;A, function>} left The result containing a function to run on the value
 * @param  {Result&lt;A, B>} right The result containing a value
 * @return {Result&lt;A, C>}
 */
Result.ap = curry((left, right) =>
  Result.chain(Result.map(__, right), left));

/**
 * @description Determine if an Result is an instance of Failure
 * @memberof Result
 * @since 1.0.0-beta
 * @function isFailure
 * @static
 * @example
 * // isFailure :: Result a b -> Bool
 * import { isFailure, Failure, Success } from 'zoomjs/result';
 *
 * isFailure(Failure.of());
 * // => true
 *
 * isFailure(Success.of());
 * // => false
 *
 * @param  {Result&lt;A, B>} result The result to query
 * @return {Boolean}
 */
Result.isFailure = result => result instanceof Result.Failure;

/**
 * @description Determine if an Result is an instance of Success
 * @memberof Result
 * @since 1.0.0-beta
 * @function isSuccess
 * @static
 * @example
 * // isSuccess :: Result a b -> Bool
 * import { isSuccess, Failure, Success } from 'zoomjs/result';
 *
 * isSuccess(Success.of());
 * // => true
 *
 * isSuccess(Failure.of());
 * // => false
 *
 * @param  {Result&lt;A, B>} result The result to query
 * @return {Boolean}
 */
Result.isSuccess = result => result instanceof Result.Success;


/*
 |------------------------------------------------------------------------------
 | Instance Members
 |------------------------------------------------------------------------------
 */

 /**
  * @description A function that accepts an object with two functions, one
  * to run if the result is an instance of `Success`, and one to run if the
  * result is an instance of `Failure`. The return value will be returned
  * directly, with no wrapper instance. This name is short for `catamorphism`.
  * An alias for {@link Result#caseOf}
  * @memberof Result
  * @since 1.0.0-beta
  * @method
  * @instance
  * @see {@link Result#caseOf}
  * @example
  * // cata Result a b :: { Failure: a -> c, Success: b -> c } -> c
  * import { Result } from 'zoomjs';
  *
  * Result.of(1).cata({
  *   Success(one) {
  *     // Do something with one
  *   },
  *
  *   Failure(error) {
  *     // Handle the error
  *   },
  * });
  *
  * @this Result
  * @param  {object} cases `{ Failure: a -> c, Success: b -> c }`
  * @param  {function} cases.Failure The `Failure` case
  * @param  {function} cases.Success The `Success` case
  * @return {Result&lt;A, C>}
  */
Result.prototype.cata = Result.prototype.cata;

 /**
  * @description A function that accepts an object with two functions, one
  * to run if the result is an instance of `Success`, and one to run if the
  * result is an instance of `Failure`. The return value will be returned
  * directly, with no wrapper instance. An alias for An alias for {@link Result#cata}
  * @memberof Result
  * @since 1.0.0-beta
  * @see {@link Result#cata}
  * @method
  * @instance
  * @example
  * // caseOf Result a b :: { Failure: a -> c, Success: b -> c } -> c
  * import { Result } from 'zoomjs';
  *
  * Result.of(1).caseOf({
  *   Success(one) {
  *     // Do something with one
  *   },
  *
  *   Failure(error) {
  *     // Handle the error
  *   },
  * });
  *
  * @this Result
  * @param  {object} cases `{ Failure: a -> c, Success: b -> c }`
  * @param  {function} cases.Failure The `Failure` case
  * @param  {function} cases.Success The `Success` case
  * @return {Result&lt;A, C>}
  */
Result.prototype.caseOf = Result.prototype.cata;

/**
 * @description Lift a value into a successful 'Success' context.
 * @memberof Result.Success
 * @since 1.0.0-beta
 * @implements Applicative
 * @method of
 * @instance
 * @example
 * // of Result a b :: c -> Result d c
 * import { Success } from 'zoomjs/result';
 *
 * Success.of(1);
 * // => Success(1)
 *
 * @this Result
 * @param  {B} value The value to put in the Result
 * @return {Result&lt;A, B>}
 */
Success.prototype.of = function of(value) {
  return Success.of(value);
};

/**
 * @description Lift a value into an unsuccessful 'Failure' context.
 * @memberof Result.Failure
 * @since 1.0.0-beta
 * @implements Applicative
 * @method of
 * @instance
 * @example
 * // of Result a b :: c -> Result c d
 * import { Failure } from 'zoomjs/result';
 *
 * Failure.of(1);
 * // => Failure(1)
 *
 * @this Result
 * @param  {A} value The value to put in the Result
 * @return {Result&lt;A, B>}
 */
Failure.prototype.of = function of(value) {
  return Failure.of(value);
};

/**
 * @description Apply a transformation to the Result if it is an instance
 * of "Success". Otherwise, ignore the transformation and return the instance.
 * This is how you can switch from a 'Success' to 'Failure' instance and stop
 * subsequent transformations from being applied. An alias for {@link Result#andThen}
 *
 * @memberof Result
 * @since 1.0.0-beta
 * @implements Chain
 * @method
 * @instance
 * @see {@link Result#andThen}
 * @example
 * // chain Result a b :: (b -> Result a c) -> Result a c
 * import { Failure, Success } from 'zoomjs/result';
 *
 * // toUpper :: String -> Result String String
 * const toUpper = x =>
 *   typeof x !== 'string'
 *     ? Failure.of('toUpper() recieved a non string.')
 *     : Success.of(x.toUpperCase());
 *
 * // A "Success" will apply the next operation
 * Success.of('boom').chain(toUpper);
 * // => Success(BOOM)
 *
 * // A "Failure" will ignore the next operation
 * Failure.of('yea right').chain(toUpper);
 * // => Failure(yea right)
 *
 * @this Result
 * @param  {function} transform The transformation to apply to the inner value
 * @return {Result&lt;A, C>}
 */
Result.prototype.chain = function chain(transform) {
  return Result.chain(transform, this);
};

/**
 * @description Apply a transformation to the Result if it is an instance
 * of "Success". Otherwise, ignore the transformation and return the instance.
 * This is how you can switch from a 'Success' to 'Failure' instance and stop
 * subsequent transformations from being applied. An alias for {@link Result#chain}
 *
 * @memberof Result
 * @since 1.0.0-beta
 * @method
 * @instance
 * @see {@link Result#chain}
 * @example
 * // andThen Result a b :: (b -> Result a c) -> Result a c
 * import { Failure, Success } from 'zoomjs/result';
 *
 * // toUpper :: String -> Result String String
 * const toUpper = x =>
 *   typeof x !== 'string'
 *     ? Failure.of('toUpper() recieved a non string.')
 *     : Success.of(x.toUpperCase());
 *
 * // A "Success" will apply the next operation
 * Success.of('boom').andThen(toUpper);
 * // => Success(BOOM)
 *
 * // A "Failure" will ignore the next operation
 * Failure.of('yea right').andThen(toUpper);
 * // => Failure(yea right)
 *
 * @this Result
 * @param  {function} transform The transformation to apply to the inner value
 * @return {Result&lt;A, C>}
 */
Result.prototype.andThen = function andThen(transform) {
  return Result.chain(transform, this);
};

/**
 * @description `map` is very similar to {@link Result.andThen} and
 * {@link Result.chain} in that it only runs the function if the
 * result is an instance of `Just`. The main difference is that {@link Result.andThen}
 * and {@link Result.chain} expect the functions you give them to return
 * new `Result` instances, and map let's you use plain old functions.
 *
 * @memberof Result
 * @since 1.0.0-beta
 * @implements Functor
 * @method
 * @instance
 * @example
 * // map Result a b :: (b -> c) -> Result a c
 * import { Failure, Success } from 'zoomjs/result';
 *
 * // toUpper :: String -> String
 * const toUpper = x => x.toUpperCase();
 *
 * // A "Success" will run the next operation
 * Success.of('yay').map(toUpper);
 * // => Success('YAY!');
 *
 * // A "Failure" will ignore the next operation
 * Failure.of('nay!').map(toUpper);
 * // => Failure('nay!');
 *
 * @this Result
 * @param  {function} transform The transformation to apply to the inner value
 * @return {Result&lt;A, C>}
 */
Result.prototype.map = function map(transform) {
  return Result.map(transform, this);
};

/**
 * @description
 * `ap` is just like `map`, allowing a user to use plain old functions to
 * transform values hidden away in `Result`s. The only difference is that
 * instead of giving it the function, you give it an `Result` of the function.
 * This is known as the `Apply` type in fantasy land JS.
 *
 * @memberof Result
 * @method
 * @instance
 * @since 1.0.0-beta
 * @implements Apply
 * @example
 * // ap Result a b :: Apply (b -> c) -> Result a c
 * import { ap, Failure, Success } from 'zoomjs';
 *
 * // toUpperE :: Result a (String -> String)
 * const toUpperE = Success(x => x.toUpperCase());
 *
 * // A "Success" will apply the next operation
 * Success.of('boom').ap(toUpperE);
 * // => Success(BOOM)
 *
 * // A "Failure" will ignore the next operation
 * Failure.of('yea right').ap(toUpperE);
 * // => Failure(yea right)
 *
 * @this Result
 * @param  {Result&lt;A, function>} apply An result containing a function to run on the value
 * @return {Result&lt;A, C>}
 */
Result.prototype.ap = function ap(apply) {
  return Result.ap(apply, this);
};

/**
 * @description Determine if an Result is an instance of Failure
 * @memberof Result
 * @since 1.0.0-beta
 * @method
 * @instance
 * @example
 * // isFailure Result a b :: c -> Bool
 * import { Failure, Success } from 'zoomjs/result';
 *
 * Failure.of(1).isFailure(); // true
 * Success.of(1).isFailure(); // false
 *
 * @this Result
 * @return {Boolean}
 */
Result.prototype.isFailure = function isFailure() {
  return Result.isFailure(this);
};

/**
 * @description Determine if an Result is an instance of Success
 * @memberof Result
 * @since 1.0.0-beta
 * @method
 * @instance
 * @example
 * // isSuccess Result a b :: c -> Bool
 * import { Failure, Success } from 'zoomjs/result';
 *
 * Success.of(1).isSuccess(); // true
 * Failure.of(1).isSuccess(); // false
 *
 * @this Result
 * @return {Boolean}
 */
Result.prototype.isSuccess = function isSuccess() {
  return Result.isSuccess(this);
};

export default Result;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sat Jul 29 2017 21:50:30 GMT-0400 (EDT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
